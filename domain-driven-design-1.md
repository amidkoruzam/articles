Part I

The main idea for this part (and the whole book) is that the program you are writing is supposed to serve some kind of purpose and it is a good idea to have at least a basic understanding of what you are actually trying to solve.

To do so you should try speaking to people who are more familiar with the field than you are. It can actually be a single person - e.g. your client if you are doing freelance work or your boss if you are working for a small company.

While doing so, most likely, from these interactions you will pick up keywords which are important for the specific domain like “student”, “course”, “assignment” or ”pass a test” if you are coding an educational project.

Naturally, you are going to use these words when communicating with non-tech people. The catch is that, according to the book, you also should use it when communicating with fellow developers and try to not use only strictly technical terms like classes and methods when talking about something. And the moment you start doing so, it will mean that your whole team has started to adapt Ubiquitous Language.

Ubiquitous Language is a pretty important term in a DDD world. Its main purpose is to not let tech and non-tech people exist in their own separate bubbles since, only through communication of both of these sides, it is possible to create useful software. And while it is a good idea to keep technical jargon to the minimum, the language doesn’t necessarily have to be strictly non-technical. The only requirement is that everybody in the team should be able to speak and understand it.

Another important term for DDD is Model - an abstraction over the problem you are solving. An example would be a map of a terrain. Obviously, a map could not convey all the little details about a place but it should be enough to navigate using it.

Model is a pretty ephemeral term. In the real world it can be expressed through Ubiquitous Language, written documents and your codebase which must contain terms from Ubiquitous Language you are using within your team. The last part is very important since if the model is not applied to the code it means that it is purely artificial.

Basically, that's the whole part. Even though the book isn’t the easiest read in the world, the main idea is not that complicated - you should not lose sight of the final goal of the software you are working on.
